#!/bin/bash
version=1.0

#initial variables
hicpath=0
myres=0
help=0
#strawpath=""
#coolerpath=""
genome=0
cpu=1
doNotMerge=0
adjustment=0
distance=0
upperlim=0
trackline=1
threshold=10
keeptracks=0
totreads=0
lowerthresh=0
window=0
verbose=0
switch=1
qthresh=0.05
whichchoice=`echo "o"`
cleanup=1
endZ=0
exclbed=0
crushdir=`echo "CRUSHtmp_""$RANDOM"`
outpre=""
coarsestres=2500000
#creates and chooses a random spinner 

function shutdown() {
  tput cnorm # reset cursor
}
trap shutdown EXIT

function cursorBack() {
  echo -en "\033[$1D"
}

function spinner() {
  # make sure we use non-unicode character type locale 
  # (that way it works for any locale as long as the font supports the characters)
  local LC_CTYPE=C

  local pid=$1 # Process Id of the previous running command

  case $(($RANDOM % 14)) in
  0)
    local spin='⠁⠂⠄⡀⢀⠠⠐⠈'
    local charwidth=3
    ;;
  1)
    local spin='-\|/'
    local charwidth=1
    ;;
  2)
    local spin="▁▂▃▄▅▆▇█▇▆▅▄▃▂▁"
    local charwidth=3
    ;;
  3)
    local spin="▉▊▋▌▍▎▏▎▍▌▋▊▉"
    local charwidth=3
    ;;
  4)
    local spin='←↖↑↗→↘↓↙'
    local charwidth=3
    ;;
  5)
    local spin='▖▘▝▗'
    local charwidth=3
    ;;
  6)
    local spin='┤┘┴└├┌┬┐'
    local charwidth=3
    ;;
  7)
    local spin='◢◣◤◥'
    local charwidth=3
    ;;
  8)
    local spin='◰◳◲◱'
    local charwidth=3
    ;;
  9)
    local spin='◴◷◶◵'
    local charwidth=3
    ;;
  10)
    local spin='◐◓◑◒'
    local charwidth=3
    ;;
  11)
    local spin='⣾⣽⣻⢿⡿⣟⣯⣷'
    local charwidth=3
    ;;
  12)
    local spin='CCCRRRUUUSSSHHH'
    local charwidth=1
    ;;
  13)
    local spin='RRROOOWWWLLLEEEYYYLLLAAABBB'
    local charwidth=1
    ;;
  esac

  local i=0
  tput civis # cursor invisible
  while kill -0 $pid 2>/dev/null; do
    local i=$(((i + $charwidth) % ${#spin}))
    printf "%s" "${spin:$i:$charwidth}"

    cursorBack 1
    sleep .1
  done
  tput cnorm
  wait $pid # capture exit code
  return $?
}



function usage {
    echo -e "\n\nusage : CRUSH_vX.X -i HIC  -g SIZEFILE -a ABED -b BBED | FASTA -r FINERESOLUTION [-cpu CPU] [-w WINDOW] [-h]"
    echo -e "Use option -h|--help for more information"
}


#Help menu function
function help {
  usage;
  echo

  echo "CRUSH will create a temporary folder in your current directory, so make sure you have write access to your current directory."
  echo "See https://github.com/JRowleyLab/CRUSH/ for full documentation on CRUSH"
  echo "-----------------------------------------"
  echo "OPTIONS:"
  
  echo "-h|--help                :  Display this help menu"
  echo " "
  echo "--------------------------REQUIRED PARAMETERS------------------"
  echo "-i|--hic                 :  Input .hic/.cooler/.mcool file by specifying the path. (e.g., '/path/to/ file.hic or file.mcool or file.cooler)"
  echo "-g|--genomesize              :  Specify path to a chromosome size file with two columns corresponding to chromosome and size respectively."
  echo "-a|--initialA                :  Specify path to a bed file with the regions for initializing A. For example, gene annotations e.g. hg19genes.bed."
  echo "-b|--initialB                :  Specify path to either a fasta file or to a bed file for initializing B. If you specify a fasta file, we will calculate intialB from gc content." 
  echo "-r|--res                 :  Resolution desired."
  echo "---------------" 
  #echo "-s|--straw               :  Specify the path to Straw for dumping reads from .hic files; OR"
  #echo "-c|--cooler              :  Specify the path to Cooler for dumping reads from .mcool or .cooler files"
  echo " "
  echo "--------------------------OPTIONAL PARAMETERS------------------"
  
  echo "-o|--outpre              :  Set this if you want to specify a prefix for the output files"
  echo "-c|--cpu               :  Set the value for cpu number of threads to use. Default is 1."
  echo "-n|--no-merge            :  Set this option to 1 to keep each resolution as a separate output file. Default is to merge in a way that provides maximum resolution."
  echo "-A|--adjustment          :  Set this option to 1 to include a adjustment of CRUSH values at the end. This adjustment shifts values based on any internal skewing of the data. Do not set this if using CRUSH to compare between two Hi-C maps."
  echo "-d|--distance            :  Using this option will filter out the distance next to the diagonal. Default is 0 which considers everything."
  echo "-u|--upperlim            :  The upperlimit of the distance away from the diagonal to consider. Default is 0 so that it considers the whole chromosome."
  echo "-t|--trackline           :  Set to 0 if you want to disable printing a bedgraph trackline header."
  echo "-T|--threshold           :  Distance normalized threshold to filter out extreme outliers."
  echo "-k|--keeptracks          :  Set to 1 in order to keep separate A and B tracks for the probability of interacting with bed file vs other regions."
  echo "-l|--lowerthresh         :  Set the value for lowerthresh."
  echo "-w|--window              :  Set to perform a sliding window average of the scores at individual resolutions. Default is to calculate the appropriate window based on sequencing depth. Set to 1 to remove sliding window."
  echo "-v|--verbose             :  Set to 1 to enable verbose mode showing extensive messages."
  echo "-S|--switch              :  Set this option to 0 for bypassing re-initialization. Default is 1."  
  echo "-C|--cleanup             :  Set the value to 0 to keep temporary files. Default is 1."
  echo "-E|--endZ                :  Set the value for endZ"
  echo "-x|--exclbed             :  Set the value for exclbed"
  echo "-q|--qvalue              :  Set the qvalue threshold. default 0.05. Set to 0 to not perform qvalue filtering. The qvalues will be reported as a separate track regardless."
  echo "-u|--use                 :  Whether to use of overwrite existing GI tracks previously calculated at individual resolutions. Set this option to u to use previous calculations. Default is to recalculate. This option is useful for merging resolutions."     
  echo "-f|--tmpfolder         :  Set this if you want to name the temporary folder yourself. Make sure it doesn't already exist in your current working directory. Default is to name it CRUSHtmp with a random number."
  echo "-m|--maxres             : Set this to the coarsest resolution you want to consider. Default is to check every resolution between 2500000 and your desired resolution to inform each other." 
  # Add more options here if needed
}


#Parsing command line arguments
while test $# -gt 0
do
        case "$1" in
                -h| --help)
                help
                exit 0
                ;;
                -i|--hic)
                hicpath=`readlink -e $2`
                ;;
				-o|--outpre)
				outpre=$2
				;;
                -r|--res)
                res=$2
                ;;
                #-s|--straw)
                #strawpath=`readlink -e $2`
                #;;
                #-c|--cooler)
                #coolerpath=`readlink -e $2`
                #;;
                -g|--genomesize)
                sizefile=`readlink -e $2`
                ;;
				-a|--initialA)
				genesfile=`readlink -e $2`
				;;
				-b|--initialB)
				fastafile=`readlink -e $2`
				;;
                -q|--qvalue)
                qthresh=$2
                ;;
		-x|--exclbed)
		exclbed=`readlink -e $2`
		;;
		-c|--cpu)
		cpu=$2
		;;
		-n|--no-merge)
		doNotMerge=$2
		;;
		-A|--adjustment)
    adjustment=$2
    ;;
		-d|--distance)
		distance=$2
		;;
		-u|--upperlim)
		upperlim=$2
		;;
		-l|--lowerthresh)
		lowerthresh=$2
		;;
		-t|--trackline)
		trackline=$2
		;;
    -T|--threshold)
		threshold=$2
		;;
		-k|--keeptracks)
		keeptracks=$2
		;;
		-w|--window)
		window=$2
		;;
		-v|--verbose)
		verbose=$2
		;;
		-S|--switch)
		switch=$2
    ;;
    -N|--norm)
		norm=$2
		;;
    -use)
		whichchoice=$2
		;;
	-f|--tmpfolder)
		crushdir=$2
		;;
		-C|--cleanup)
		cleanup=$2
		;;
		-E|--endZ)
		endZ=$2
		;;
		-m|--maxres)
		coarsestres=$2
		;;
        esac
        shift
done

#Checking if arguments are provided

#if [ -z "$strawpath" ] && [ -z "$coolerpath" ]; then
#  echo "You must specify a path to either juicers straw function or cooler function!....."
#  usage
#  exit 1
#fi
if [ $hicpath == 0 ]
then
echo "You must specify a .hic file!......""$menu"
exit 0
fi
if [ $res == 0 ]
then
echo "You must specify a resolution!......""$menu"
exit 0
fi
if [ $switch == 0 ]
then
echo "Warning: Re-evaluation & Re-interation of A and B Bins has been deactivated. We recommend leaving this parameter alone to achieve highest possible confidence and resolution."
fi

# Check if the size file is provided
if [ -z "$sizefile" ] || [ -z "$genesfile" ] || [ -z "$fastafile" ]; then
    echo "Missing one or more required arguments: --genomesize, --initialA, or --initialB!..."
    help
    exit 1
fi

if [ $doNotMerge == 1 ]
then
echo "Warning: doNotMerge set. We recommend merging to achieve highest possible confidence and resolution. Only set doNotMerge if you plan to merge the individual resolutions later."
fi

if [ $adjustment == 1 ]
then
echo "Warning: adjusting end compartmental values which may result in some loss of quantitative power. We recommend adjustment only for troubleshooting or when not comparing two samples."
fi

echo "CRUSH_v""$version"" -i ""$hicpath"" -r ""$res"" -g ""$sizefile"" -a ""$genesfile"" -b ""$fastafile"" --cpu ""$cpu"" --no-merge ""$doNotMerge"" --adjustment ""$adjustment"" --distance ""$distance"" --upperlim ""$upperlim"" --lowerthresh ""$lowerthresh"" --trackline ""$trackline"" --threshold ""$threshold"" --keeptracks ""$keeptracks"" --window ""$window"" --switch ""$switch"" --maxres ""$coarsestres" > "$outpre"CRUSHparamters.txt

#check for .hic or .mcool
juiceorcool=`echo "$hicpath" | sed 's/\./\t/g' | sed 's/\./\t/g' | awk '{if ($NF == "hic") print 0; else if ($NF == "mcool") print 1; else print 2}'`

if [ $juiceorcool == 2 ]
then
echo "You must choose a Hi-C file that ends in either .hic (juicer) or .mcool (cooler)"
exit 0
elif [ $juiceorcool == 0 ]
then
echo "Identified .hic juicer format. We will use the pythonic hicstraw to extract the data and assume you have it installed, using pip install hic-straw."
else
echo "Identified .mcool format. We will use cooler to extract the data and assume you have it installed in your path."
fi

###################################################################
echo "Creating and moving into temporary directory"
mkdir $crushdir
cd $crushdir



#Reading Resolutions

if [ $juiceorcool -eq 0 ]
then
cat << EOF > listres.py
import hicstraw
hic = hicstraw.HiCFile("$hicpath")
totres=hic.getResolutions()
keepres=[]
for i in totres:
	if (int(i) >= int("$res")) and (int(i) <= int("$coarsestres")):
		keepres.append(str(i))
print(",".join(keepres))

EOF

res=`python listres.py`

else
reslist=`cooler ls $hicpath | sed 's/\//\t/g' | awk -v var=$res -v cres=$coarsestres '{if (($NF >= var) && ($NF <= cres)) print $NF}' | sort -k 1bnr,1b --stable | awk '{if (NR == 1) printf "%s", $1; else printf ",%s", $1}' | awk '{print $0}'`
res=$reslist
fi






process_oppocheck_statement() {
  local innie_genes="$1"
  local innie_gc="$2"
  local outie_oppo="$3"
  local outie_pvalues="$4"
  
numbinsA=`wc -l $innie_genes | awk '{print $1}'`
numbinsB=`wc -l $innie_gc | awk '{print $1}'`

mawk 'NR==FNR { c1[$1] = $2; next} {if ($1 in c1) print $2"\t"$3; next} {print $0}' $innie_genes $tmpfiles/RowZs $tmpfiles/$zfile | awk '{b[$1]+=$2;c[$1]++;d[$1]+=($2**2)} END { for (i in b) { print i"\t"(b[i])*(c[i])"\t"c[i]"\t"b[i]/c[$1]"\t"((d[i]/(c[$1])-((b[i]/(c[$1]))**2)))**.5 } } ' > $tmpfiles/$A2removedfile &
mawk 'NR==FNR { c1[$1] = $2; next} {if ($1 in c1) print $2"\t"$3; next} {print $0}' $innie_gc $tmpfiles/RowZs $tmpfiles/$zfile | awk '{b[$1]+=$2;c[$1]++;d[$1]+=($2**2)} END { for (i in b) { print i"\t"(b[i])*(c[i])"\t"c[i]"\t"b[i]/c[$1]"\t"((d[i]/(c[$1])-((b[i]/(c[$1]))**2)))**.5 } } ' > $tmpfiles/$B2removedfile &

wait

myABsum=`cat $tmpfiles/$A2removedfile $tmpfiles/$B2removedfile | mawk '{sum+=$3} END {print sum}'`

wait

if [ "$verbose" -gt 0 ]
then
end=$(date +%s)
seconds=$(echo "$end - $start" | bc)
echo "It took ""$seconds"" seconds. Comparing A vs B scores for ""$mychr"" chromosome."
start=$(date +%s)

fi

wait

#Calculating the output
mawk -v var=$myres -v myABsum=$myABsum '{if ($1 in b) b[$1]-=$2; else b[$1]=$2} END { for (i in b) {  if (b[i] != 0) print i"\t"(b[i])/myABsum } } ' $tmpfiles/$A2removedfile $tmpfiles/$B2removedfile | sort -k 1bn,1b --stable | mawk -v mchr=$mychr -v myres=$myres -v window=$newwindow -v OFS="\t" 'BEGIN{slide=1} {mod=NR%window; if(NR<=window){print mchr, int($1), $2; count++}else{sum-=array[mod]}sum+=$2;array[mod]=$2;} (NR%slide)==0{print mchr,int($1-((myres*window)/2)),sum/count}' | mawk -v myres=$myres '{print $1"\t"$2-int(myres/2)+myres"\t"$2+(int(myres/2))+myres"\t"$3}' | mawk '{if ($2 > 0) print $0}' > $outie_oppo 2> $tmpfiles/$errorfile

#calculating pvalues
#awk 'NR==FNR { c[$1] = $3; m[$1] = $4; sd[$1]=$5; next} {if (($1 in m) && ($3 != 1) && (c[$1] != 1)) print $1"\t"(m[$1]-$4)/(((((c[$1]-1)*(sd[$1]**2) + ($3-1)*($5**2)) / (c[$1] + $3 -2 ))**.5)*(((1/c[$1]) + (1/$3))**.5))"\t"(c[$1] + $3 -2) }' $tmpfiles/$A2removedfile $tmpfiles/$B2removedfile > $tmpfiles/$ttable
awk 'NR==FNR { c[$1] = $3; m[$1] = $4; sd[$1]=$5; next} {if (($1 in m) && ($3 != 1) && (c[$1] != 1)) print $1"\t"(m[$1]-$4)/((((sd[$1]**2)/c[$1]) + (($5**2)/$3))**.5)"\t"(c[$1] + $3 -2) }' $tmpfiles/$A2removedfile $tmpfiles/$B2removedfile > $tmpfiles/$ttable

zfileforpy=`echo "$tmpfiles""/""$ttable"`
pfileforpy=`echo "$tmpfiles""/""$ptable"`

cat << EOF > zlookup.py
import scipy.stats
inputfile = "$zfileforpy"
outfile = "$pfileforpy"
mybins=[]
mypvals=[]
with open(inputfile, 'r') as innie:
        for line in innie:
                sline = line.strip()
                lines = sline.split("\t")
                mybins.append(str(lines[0]))
                mytstat = float(lines[1])
                mydf = int(lines[2])
                mypvals.append(scipy.stats.norm.sf(abs(mytstat)))
with open(outfile, 'w') as outie:
        for w in range(0,len(mybins)):
                outie.write(str(mybins[w]) + "\t" + str(mypvals[w]) + "\n")
EOF
python zlookup.py

mawk -v mchr=$mychr -v myres=$myres '{print mchr"\t"$1"\t"$1+myres"\t"$2}' $tmpfiles/$ptable > $outie_pvalues
wait

if [ "$exclbed" != 0 ]
then
exclbins=`echo "$tmpfiles""/exclbins"`
excloutie=`echo "$tmpfiles""/exclout_""$myres""_""$mychr"`

cat $exclbed | mawk -v myres=$myres -v mychr=$mychr '{if ($1 == mychr) print $1"\t"int($2/myres)*myres"\t"int($3/myres)*myres}' | awk -v myres=$myres '{for (i=$2;i<=$3;i+=myres) b[i]+=1}  END { for (j in b) print j"\t"b[j]} ' > $exclbins

wait

mawk 'NR==FNR { c1[$1] = $2; next} {if ($2 in c1); else print $0}' $exclbins $outie_oppo > $excloutie

wait

mv $excloutie $outie_oppo
fi

if [ $keeptracks -eq 1 ]
then
rawcomp=`echo "rawcompvectors"`

fi

if [ "$oppocheck" -gt 0 ] && [ "$adjustment" -gt 0 ]
then
#amed=`mawk 'NR==FNR { c1[$1] = $2; next} {if ($2 in c1) print $4}' $sortedbed $outie | mawk '{sum +=$1} END {print sum/NR}'`
#bmed=`mawk 'NR==FNR { c1[$1] = $2; next} {if ($2 in c1); else print $4}' $sortedbed $outie | mawk '{sum += $1} END {print sum/NR}'`
amed=`mawk 'NR==FNR { c1[$1] = $2; next} {if ($2 in c1) print $4}' $innie_genes $outie_oppo | mawk '{sum +=$1} END {print sum/NR}'`
bmed=`mawk 'NR==FNR { c1[$1] = $2; next} {if ($2 in c1); else print $4}' $innie_genes $outie_oppo | mawk '{sum += $1} END {print sum/NR}'`

wait

cat $outie | mawk -v varA=$amed -v varB=$bmed '{print $1"\t"$2"\t"$3"\t"$4-(varA-(varB*-1))}' > $outie2

wait

mv $outie2 $outie_oppo
fi

if [ "$myres" -ge "$endZ" ]
then
#echo "Applying end ending score normalization"
myendmean=`cat $outie | mawk '{sum += $4; cnum++} END {print sum/cnum}'`
#echo "$myendmean"
tmpendZ=`echo $tmpfiles"/tmpendnorm"`
cat $outie_oppo | mawk -v mymean=$myendmean '{print $1"\t"$2"\t"$3"\t"($4-mymean)}' > $tmpendZ

wait

mv $tmpendZ $outie_oppo
fi

}

#Calculations start from here--------------------------------------------------------------------------------------------------------------------------------------


# Check for fasta
isfasta=`head -1 $fastafile | awk '{if ($1 ~ /^>/) print 1; else print 0}'`


# Display the file paths
echo "initial-A: $genesfile"
echo "sizes-file: $sizefile"

#check sizefile
numcolumns=`mawk '{if (NF != 2) print $0}' $sizefile | wc -l`
if [ "$numcolumns" -gt 0 ]
then
echo "size file is incorrect format. It should be two columns with chromosome name and size"
exit 0
fi

totchroms=`cat $sizefile | wc -l`
maxres=`echo "$res" | sed "s/,/ /g" | mawk '{max=$1;for(i=2;i<=NF;i++){if($i > max) max = $i} print max}'`
minres=`echo "$res" | sed "s/,/ /g" | mawk '{min=$1;for(i=2;i<=NF;i++){if($i < min) min = $i} print min}'`


if [ $isfasta == "1" ]
then
echo "Fasta-file: $fastafile"
else
echo "initial-B: $fastafile"
fi

resbins=`echo "size_bins"".bed"`
gcfile=`echo "gc_bins"".txt"`
gc_g_ga=`echo "gc_g_ga_bins"".bed"`
Bbins=`echo "Bbins"".bed"`

if [ $minres -ge 500 ]
then
cat $sizefile | awk -v myres=500 '{for (i=0;i<=$2;i+=myres) print $1"\t"i"\t"i+myres}' > $resbins
echo "$resbins calculated at 500bp resolution"
else
cat $sizefile | awk -v myres=$minres '{for (i=0;i<=$2;i+=myres) print $1"\t"i"\t"i+myres}' > $resbins
echo "$resbins calculated at ""$minres"" resolution"
fi
wait

if [ $isfasta == "1" ]
then
echo "Now, calculating the gc content:"
bedtools nuc -fi $fastafile -bed $resbins > $gcfile
wait
#echo "$gcfile generated"
#Created a %G/%G+%A file in 7th column
cat $gcfile | grep -v user | cut -f 1-5 | awk '{print $0"\t"($4+$5)}' | awk '{if ($6 > 0) print $0}' | awk '{print $0"\t"($5/$6)}' > $gc_g_ga
wait
#Calculating mean and SD for the whole genome and then subtracting 2SD from the mean
gc_thresh=`cat $gc_g_ga | awk '{s+=$7; ss+=$7*$7; linecount+=1} END{print m=s/linecount, sqrt(ss/linecount-m^2)}' | awk '{print $0}' | awk '{print $1 - 1*$2}'`
if [ $verbose -gt 0 ]
then
echo "gc threshold is ""$gc_thresh"
fi
#Generating the bins by considering the bins below
cat $gc_g_ga | awk -v thresh=$gc_thresh '{if ($7 < thresh) print $0}' > $Bbins
wait
echo "Finished generating Bbins file for all chromosomes "

else
cat $fastafile > $Bbins
fi

if [ $endZ == 0 ]
then
endZ=`echo "$minres"`
fi

countres=0
coarse_res=$maxres
crtmp=$maxres

for myres in $(echo $res | sed "s/,/ /g")
do
high_res=$myres
if [ $window == 0 ]
then

#Changed the below line from mawk to awk as mawk was throwing an error while working through script line by line
totbins=`cat $sizefile | awk -v var=$myres '{print $1"\t"($2/var)**2}' | awk '{sum += $2} END {print sum}'`

newwindow=1
else
newwindow=`echo "$window"`

#Calculating window sizes for the resolutions 
newwindow=$(mawk -v win=$window -v res=$myres 'BEGIN{print int(win/(res/1000))+1}')
fi

outiefull=`echo "Crush_""$myres"".bedgraph"`
outiefullPval=`echo "pvalues_""$myres"".bedgraph"`
VCSQRToutiefull=`echo "Crush_VCSQRT_""$myres"".bed"`
Aoutiefull=`echo "ACrush_""$myres"".bedgraph"`
Boutiefull=`echo "BCrush_""$myres"".bedgraph"`

outcheck=0
outcheck=`ls | grep $outiefull`
if [ "$outiefull" == "$outcheck" ]
then
echo "$outiefull"" already exists.... exiting."
exit 0
fi

echo -e "\nNow dumping reads and calculating initial CRUSH for all chromosomes at ""$myres"

task(){

mychr=`cat $sizefile | head -n $myiter | tail -1 | cut -f 1`
mysize=`cat $sizefile | head -n $myiter | tail -1 | cut -f 2`
rowbins=`cat $sizefile | head -n $myiter | tail -1 | mawk -v myres=$myres '{print int($2/myres)+1}'`
outie=`echo "Crush_""$myres""_""$mychr""_tmp"`
pscores=`echo "ttest_""$myres""_""$mychr""_tmp"`
outieRegular=`echo "Crush_""$myres""_""$mychr""_tmpReg"`
outiePerm=`echo "Crush_""$mychr""_tmpPerm.txt"`
outiePermOppo=`echo "Crush_""$myres""_""$mychr""_tmpPermOppo"`
outie2=`echo "Crush_""$myres""_""$mychr""_tmp2"`
tmpfiles=`echo "ABtmpfiles_""$mychr""_""$myres"`
Aoutie=`echo "ACrush_""$myres""_""$mychr""_tmp"`
Boutie=`echo "BCrush_""$myres""_""$mychr""_tmp"`

#echo "Processing files for Genes and GC: $innie1 $innie2" 
Atmp=`echo "$tmpfiles""/Atmp"`
Btmp=`echo "$tmpfiles""/Btmp"`

Atmppseudo=`echo "$tmpfiles""/Atmpp_""$mychr""_""$myres"`
Btmppseudo=`echo "$tmpfiles""/Btmpp_""$mychr""_""$myres"`

Afile=`echo "tmpA"`
Bfile=`echo "tmpB"`
Bpfile=`echo "tmpBp"`
Apfile=`echo "tmpAp"`

A2file=`echo "tmpA2"`
B2file=`echo "tmpB2"`
Ap2file=`echo "tmpAp2"`
Bp2file=`echo "tmpBp2"`

#shuffled_combined_file="shuffled_files_${p}.txt" 

#splitA=`echo "$tmpfiles""/splitA.txt"`
#splitB=`echo "$tmpfiles""/splitB.txt"`

#outiefull_permutation=`echo "Crush_permutation.bedgraph"`

mkdir $tmpfiles

efile=`echo "expecteds"`
ofile=`echo "observeds"`
mydist=$((distance + 0))
myupper=$((upperlim + 0))
if [ "$verbose" -gt 0 ]
then
echo "Getting genic bins."
fi
sortedbed=`echo "$tmpfiles""/genebins"`
pseudoB=`echo "$tmpfiles""/pseudoB"`
pseudoA=`echo "$tmpfiles""/pseudoA"`
dumped=`echo "$tmpfiles""/dumped_""$myres""_""$mychr""_tmp"`

#Adding VCoutie which has information about vc normalizaion for each chromosome
VCSQRT=`echo "VCSQRT_""$myres""_""$mychr""_tmp"`

#Adding in the code for re-initializing Bbins for next following resolutions
if [ "$myres" == "$maxres" ] 
then

#Processing the genes & Bbins files
cat $genesfile | mawk -v myres=$maxres -v mychr=$mychr '{if ($1 == mychr) print $1"\t"int($2/myres)*myres"\t"int($3/myres)*myres}' | awk -v myres=$maxres '{for (i=$2;i<=$3;i+=myres) b[i]+=1}  END { for (j in b) print j"\t"b[j]} ' > $sortedbed

#Bbins
cat $Bbins |  mawk -v myres=$maxres -v mychr=$mychr '{if ($1 == mychr) print $1"\t"int($2/myres)*myres"\t"int($3/myres)*myres}' | awk -v myres=$maxres '{for (i=$2;i<=$3;i+=myres) b[i]+=1}  END { for (j in b) print j"\t"b[j]} ' > $pseudoB

else

#Processing the genes & Bbins files for other resolutions 
cat $combined_newAbins | mawk -v myres=$myres -v mychr=$mychr '{if ($1 == mychr) print $1"\t"int($2/myres)*myres"\t"int($3/myres)*myres}' | awk -v myres=$myres '{for (i=$2;i<=$3;i+=myres) b[i]+=1}  END { for (j in b) print j"\t"b[j]} ' > $sortedbed

#Bbins
cat $combined_newBbins |  mawk -v myres=$myres -v mychr=$mychr '{if ($1 == mychr) print $1"\t"int($2/myres)*myres"\t"int($3/myres)*myres}' | awk -v myres=$myres '{for (i=$2;i<=$3;i+=myres) b[i]+=1}  END { for (j in b) print j"\t"b[j]} ' > $pseudoB

fi

#Adding in the code for bypassing re-initializing Bbins for next following resolutions
if [ "$switch" -lt 1 ]
then

#Processing the genes & Bbins files
cat $genesfile | mawk -v myres=$myres -v mychr=$mychr '{if ($1 == mychr) print $1"\t"int($2/myres)*myres"\t"int($3/myres)*myres}' | awk -v myres=$myres '{for (i=$2;i<=$3;i+=myres) b[i]+=1}  END { for (j in b) print j"\t"b[j]} ' > $sortedbed

#Bbins
cat $Bbins |  mawk -v myres=$myres -v mychr=$mychr '{if ($1 == mychr) print $1"\t"int($2/myres)*myres"\t"int($3/myres)*myres}' | awk -v myres=$myres '{for (i=$2;i<=$3;i+=myres) b[i]+=1}  END { for (j in b) print j"\t"b[j]} ' > $pseudoB

fi

if [ "$verbose" -gt 0 ]
then
echo "Dumping ""$mychr"" chromosomal reads."
fi

newofile=`echo "$tmpfiles""/observeds"`
newefile=`echo "$tmpfiles""/expecteds"`
errofile=`echo "errorlog"`

#Conditional argument for straw vs cooler usage
dumperrors=`echo "dumperrors_""$myres"`
if [ $juiceorcool -eq 0 ]
then

#echo "Dumping using straw..."

#Dumping ofile and efile using no normalization schemes (Uncommented from previous version) using straw
cat << EOF > dumper.py
import hicstraw
result = hicstraw.straw('observed', 'NONE', "$hicpath", "$mychr", "$mychr", "BP", int("$myres"))
for i in range(len(result)):
	print("{0}\t{1}\t{2}".format(result[i].binX, result[i].binY, result[i].counts)) 

EOF

python dumper.py | grep -v WARN > $dumped 2> $dumperrors

#$strawpath NONE $hicpath $mychr $mychr BP $myres | grep -v WARN > $dumped 2> $dumperrors

else
echo "Dumping using cooler..."

#Dumping reads for cooler files
cooler dump $hicpath::/resolutions/$myres -r $mychr --join | cut -f 2,5,7 > $dumped 2> $dumperrors

fi

chromcheck=`cat dumperrors_$myres | grep -e KeyError -e name | wc -l`

if [ $chromcheck -gt 0 ]
then
echo "WARNING: A chromosome in your size file was not found in the .mcool file. Make sure the names match up. For example, check for chr1 vs. 1."
fi

wait

if [ "$upperlim" -gt 0 ]
then
cat $dumped | awk -v var=$myres -v distfilt=$mydist -v upper=$upperlim '{if (($2-$1 > distfilt) && ($2-$1 <= upper)) print ($2-$1)/var"\t"$1"\t"$2"\t"$3}' | awk -v var=$myres -v mychrsize=$mysize -v newofile=$newofile -v newefile=$newefile '{b[$1]+=$4; print $0 >> newofile } END { for (i in b) print i"\t"b[i]/((mychrsize/var)-i) >> newefile } ' &
else
cat $dumped | awk -v var=$myres -v distfilt=$mydist '{if ($2-$1 > distfilt) print ($2-$1)/var"\t"$1"\t"$2"\t"$3}' | awk -v var=$myres -v mychrsize=$mysize -v newofile=$newofile -v newefile=$newefile '{b[$1]+=$4; print $0 >> newofile } END { for (i in b) print i"\t"b[i]/((mychrsize/var)-i) >> newefile } ' &
fi

wait 

#Calculating VC_SQRT using dumped reads at highest resolution:
#cat $dumped | awk '{b[$2]+=$3; b[$1]+=$3; c+=$3*2} END { for (i in b) { print i"\t"b[i]"\t"c } }'  | awk '{a[$1] = $2; b[$1] = $3; count+=1} END {for (i in a) {print i"\t"a[i]"\t"b[i]"\t"count}}' | awk '{print $1"\t"$2"\t"$3/$4}' | awk '{print $1"\t"sqrt($2/$3)}' > $VCSQRT &

wait

if [ "$verbose" -gt 0 ]
then
echo "Done dumping."
fi

if [ "$verbose" -gt 0 ]
then
echo "Now getting distance normalized values for ""$mychr"" chromosome."
start=$(date +%s)
fi

errorfile=`echo "errorlog"`

onfile=`echo "$tmpfiles""/distnorms"`
tmpmean=`echo "$tmpfiles""/tmpmean"`
symmfile=`echo "$tmpfiles""/symmonfile"`

#Changing newefile2 and newofile2 to newefile and newofile
mawk 'NR==FNR { c1[$1] = $2; next} {if ($2 != $3) print $2"\t"$3"\t"($4+1)/(c1[$1]+1)}' $newefile $newofile | mawk -v thresh=$threshold '{if ($3 < thresh) print $1"\t"$2"\t"$3"\n"$2"\t"$1"\t"$3; else print $1"\t"$2"\t"thresh"\n"$2"\t"$1"\t"thresh}' | awk -v symmfile=$symmfile -v tmpmean=$tmpmean -v rowbins=$rowbins '{m[$1]+=$3;d[$1]+=($3**2); print $0 >> symmfile} END {for (i in m) print i"\t"m[i]/rowbins"\t"((d[i]/rowbins-((m[i]/rowbins)**2))**.5) >> tmpmean }'  2> $tmpfiles/$errorfile

wait

if [ "$verbose" -gt 0 ]
then
end=$(date +%s)
seconds=$(echo "$end - $start" | bc)
#echo "Done normalizing. It took ""$seconds" "seconds. Now cleaning up a bit for ""$mychr"" chromosome."
start=$(date +%s)
fi

if [ "$myres" -gt 50000 ]
then
oppocheck=`mawk 'NR==FNR { c1[$1] = $2; next} {if ($1 in c1) ; else if ($2 in c1); else print $0}' $sortedbed $symmfile | wc -l`
else
oppocheck=2
fi

# Calling the else statement function. 

#perform real calculation
if [ "$oppocheck" -lt 1 ] && [ "$verbose" -gt 0 ]
then
echo "WARNING: All bins on chromosome ""$mychr"" overlap with your bed file at ""$myres"" resolution"". This should not affect the scores if using multiple resolutions. If using a single resolution, then maybe not use this resolution?."
fi


myzscore=`echo "Zscorefile"`
if [ "$verbose" -gt 0 ]
then
end=$(date +%s)
seconds=$(echo "$end - $start" | bc)
#echo "Got means and stdevs, It took ""$seconds"" seconds. Now applying z-scores values for ""$mychr"" chromosome."
start=$(date +%s)
fi

#Calculating Z-scores
mawk 'NR==FNR { m[$1]=$2; d[$1]=$3; next} {if (d[$2] > 0) print $1"\t"$2"\t"($3-m[$2])/(d[$2])}' $tmpmean $symmfile > $tmpfiles/RowZs


zfile=`echo "zerofile"`
cat $sizefile | mawk -v var=$mychr '{if ($1 == var) print $0}' | mawk -v wlkr=$myres '{for (i=0;i<=$2;i+=wlkr) print i"\t"i"\t0.1"}' > $tmpfiles/$zfile

A2removedfile=`echo "A2removed"`
B2removedfile=`echo "B2removed"`
ttable=`echo "ttable"`
ptable=`echo "ptable"`
process_oppocheck_statement $sortedbed $pseudoB $outie $pscores


if [ "$cleanup" -gt 0 ]
then
rm -r $tmpfiles
fi

}

open_sem(){
    mkfifo pipe-$$
    exec 3<>pipe-$$
    rm pipe-$$
    local i=$1
    for((;i>0;i--)); do
        printf %s 000 >&3
    done
}

run_with_lock(){
    local x
    read -u 3 -n 3 x && ((0==x)) || exit $x
    (
     ( "$@"; )
    
    printf '%.3d' $? >&3
    )& spinner $!
}


open_sem $cpu 

if [ "$whichchoice" == "o" ]
then

for (( myiter=1; myiter<=$totchroms; myiter++ ))
do
    run_with_lock task $myiter
done

wait



#Merging GI files

echo -ne "Merging individual chromosome files\033[0K\r"
cat Crush*_tmp | grep -v -i nan | sort -k 1,1 -V -k 2bn,2b -k 3bn,3b --stable > $outiefull


#cat VCSQRT*_tmp | grep -v -i nan | sort -k 1,1 -V -k 2bn,2b -k 3bn,3b --stable > $VCSQRToutiefull

cat ttest_*_tmp | grep -v -i nan | sort -k 1,1 -V -k 2bn,2b -k 3bn,3b --stable > $outiefullPval
wait 
rm ttest_*_tmp
#fi

###################################################################################

wait

if [ "$myres" == "$maxres" ]
then
coarse_infile=`echo "GI_""$myres"".bedgraph"`
cat $outiefull > $coarse_infile

wait
fi
res_values=`echo "res_values"`
echo "$myres" >> $res_values

#Re-evaluating both A and B bins for re-initialization for next resolution

if [ "$countres" -gt 0 ]
then

# Print current coarse and high resolutions
#echo "Coarse resolution: ""$coarse_res"", High resolution: ""$high_res"


#Creating a python output file 
python_output=`echo "shifter.bedgraph"`

if [ "$coarse_res" -eq "$maxres" ] && [ "$coarse_res" != "$high_res" ]
then

# Shifter Input files for the specified resolutions
high_res_infile=`echo "$outiefull"`
coarse_res_infile=`echo "$coarse_infile"`

else
# Shifter Input files for the specified resolutions
high_res_infile=`echo "$outiefull"` 
coarse_res_infile=`echo "$python_output"`

fi

# Conditional checking for multiples of resolutions for shifter 
#If coarseres is divisible by highres, use these resolutions for shifter as coarse and high
if [[ "$(( $coarse_res % $high_res ))" -eq 0 ]]
then
#echo "Coarse resolution: ""$coarse_res"", High resolution: ""$high_res"

crtmp=$coarse_res

else

if [[ "$(( $crtmp % $high_res ))"  -eq 0 ]]
then

#echo $crtmp

coarse_res=$crtmp

#echo $coarse_res

#echo "Coarse resolution: ""$crtmp"", High resolution: ""$high_res"

fi

fi

echo -ne "Executing Shifter using Coarse resolution: ""$coarse_res"" and High resolution:  ""$high_res""\033[0K\r"


#Executing the python script
cat << EOF > hdrescompare.py
import numpy as np
from tqdm import tqdm

# File paths and parameters
sizefile = "$sizefile"
res = int("$high_res")
coarseres = int("$coarse_res")
infile1 = "$high_res_infile"
infile2 = "$coarse_res_infile"
outiewrite = "$python_output"

# Read chromosome names and sizes
chrnames = []
chrsizes = []
with open(sizefile, 'r') as innie:
    for line in innie:
        sline = line.strip()
        lines = sline.split("\t")
        chrnames.append(lines[0])
        chrsizes.append(int(lines[1]))

# Initialize matrices
chrmat = [[] for _ in chrnames]
smat = [[] for _ in chrnames]
emat = [[] for _ in chrnames]
scoremat = [[] for _ in chrnames]
coscoremat = [[] for _ in chrnames]

# Populate base matrices
for i in tqdm(range(len(chrnames))):
    for j in range(0, chrsizes[i] + coarseres + coarseres, res):
        chrmat[i].append(chrnames[i])
        smat[i].append(j)
        emat[i].append(j + res)
        scoremat[i].append(0)
        coscoremat[i].append(0)

# Read high-resolution scores
with open(infile1, 'r') as innie:
    for line in innie:
        sline = line.strip()
        lines = sline.split("\t")
        try:
            myindex = chrnames.index(lines[0])
            mypos = int(float(lines[1])/res)
            scoremat[myindex][mypos] = float(lines[3])
        except (ValueError, IndexError):
            continue

# Rolling window size (number of high-resolution bins to consider)
window_size = 3 * (coarseres // res)

# Rolling average calculation
rolling_avg_scores = [[] for _ in chrnames]
for c in range(len(scoremat)):
    for i in range(len(scoremat[c])):
        window_start = max(0, i - window_size // 2)
        window_end = min(len(scoremat[c]), i + window_size // 2)
        window_scores = scoremat[c][window_start:window_end]
        rolling_avg_scores[c].append(np.mean(window_scores))

# Initialize shifted_scores with zeros
shifted_scores = [[0 for _ in range(len(scoremat[c]))] for c in range(len(scoremat))]

# Calculate shifted scores
for c in range(len(scoremat)):
    for i in range(len(scoremat[c])):
        mymean = rolling_avg_scores[c][i]
        coarscore = coscoremat[c][i] if i < len(coscoremat[c]) else 0  # Handle index if out of range
        shiftval = mymean - coarscore
        newval = scoremat[c][i] - shiftval
        shifted_scores[c][i] = newval

# Write output
with open(outiewrite, "w") as ofile:
    for w in range(len(shifted_scores)):
        for p in range(len(shifted_scores[w])):
            ofile.write(f"{chrmat[w][p]}\t{smat[w][p]}\t{emat[w][p]}\t{shifted_scores[w][p]}\n")


EOF

python hdrescompare.py

wait


#Seperating out A and B regions from the outiefull and intersecting them with genes and Bbins to improve compartments identification.

AbinsR=`echo "AbinsfromGI_""$myres"".txt"`
BbinsR=`echo "BbinsfromGI_""$myres"".txt"`

newBbins=`echo "newBbinsGI_""$myres"".txt"`
newAbins=`echo "newAbinsGI_""$myres"".txt"`

non_newBbins=`echo "non_newBbinsGI_""$myres"".txt"`
non_newAbins=`echo "non_newAbinsGI_""$myres"".txt"`

combined_newBbins=`echo "combined_newBbinsGI_""$myres"".txt"`
combined_newAbins=`echo "combined_newAbinsGI_""$myres"".txt"`

cat $python_output | awk '{if ($4 > 0) print $0}' > $AbinsR

cat $python_output | awk '{if ($4 < 0) print $0}' > $BbinsR

if [ "$switch" -eq 1 ]
then

echo "Re-initialization of Bins is switched ""ON"". Re-evaluating both A and B bins and re-initializing for next resolution."

cat $Bbins | intersectBed -u -a stdin -b $BbinsR > $newBbins

#echo "Printing out the file with bins on the chromosomes not present in ""$newBbins"" at ""$myres""."

awk 'NR==FNR{a[$1]=$1;next}!a[$1]' $newBbins $Bbins > $non_newBbins

cat $newBbins $non_newBbins > $combined_newBbins 

cat $genesfile | cut -f 1-3 | intersectBed -u -a stdin -b $AbinsR > $newAbins

awk 'NR==FNR{a[$1]=$1;next}!a[$1]' $newAbins $genesfile > $non_newAbins

cat $newAbins $non_newAbins > $combined_newAbins 

else

echo "Generating the output without re-initialization."

fi

# Update coarse and high resolutions
coarse_res=$high_res

else

#Seperating out A and B regions from the outiefull and intersecting them with genes and Bbins to improve compartments identification.

AbinsR=`echo "AbinsfromGI_""$myres"".txt"`
BbinsR=`echo "BbinsfromGI_""$myres"".txt"`

newBbins=`echo "newBbinsGI_""$myres"".txt"`
newAbins=`echo "newAbinsGI_""$myres"".txt"`

non_newBbins=`echo "non_newBbinsGI_""$myres"".txt"`
non_newAbins=`echo "non_newAbinsGI_""$myres"".txt"`

combined_newBbins=`echo "combined_newBbinsGI_""$myres"".txt"`
combined_newAbins=`echo "combined_newAbinsGI_""$myres"".txt"`

cat $outiefull | awk '{if ($4 > 0) print $0}' > $AbinsR

cat $outiefull | awk '{if ($4 < 0) print $0}' > $BbinsR

if [ "$switch" -eq 1 ]
then

echo "Re-initialization of Bins is switched ""ON"". Re-evaluating both A and B bins and re-initializing for next resolution."

cat $Bbins | intersectBed -u -a stdin -b $BbinsR > $newBbins

#echo "Printing out the file with bins on the chromosomes not present in ""$newBbins"" at ""$myres""."

awk 'NR==FNR{a[$1]=$1;next}!a[$1]' $newBbins $Bbins > $non_newBbins

cat $newBbins $non_newBbins > $combined_newBbins 

cat $genesfile | cut -f 1-3 | intersectBed -u -a stdin -b $AbinsR > $newAbins

awk 'NR==FNR{a[$1]=$1;next}!a[$1]' $newAbins $genesfile > $non_newAbins

cat $newAbins $non_newAbins > $combined_newAbins 

else

echo "Generating the output without re-initialization."

fi

fi

fi

if [ $keeptracks -eq 1 ] && [ "$whichchoice" == "o" ]
then
cat ACrush*_tmp | sort -k 1,1 -V -k 2bn,2b -k 3bn,3b --stable > $Aoutiefull &
cat BCrush*_tmp | sort -k 1,1 -V -k 2bn,2b -k 3bn,3b --stable > $Boutiefull &
fi
wait
rm Crush*_tmp 2> smallerrors
rm ACrush*_tmp 2> smallerrors
rm BCrush*_tmp 2> smallerrors

countres=$((countres+1))
done
if [ $doNotMerge -eq 1 ]
then
echo "Finished with each resolution listed, but not merging...."
exit 0
fi

countres=0
for totres in $(echo $res | sed "s/,/\n/g" | sort -k 1bn,1b --stable | sed "s/\n/ /g" )
do
echo "$totres" >> GIrestmpfile
countres=$((countres+1))
done

if [ $countres -le 1 ]
then
echo "Only one resolution listed, so nothing to merge. Check Crush_""$totres"".bedgraph for the single resolution GI score"


rm AbinsfromGI_*.txt 2> smallerrors
rm BbinsfromGI_*.txt 2> smallerrors
rm newAbinsGI_*.txt 2> smallerrors
rm newBbinsGI_*.txt 2> smallerrors
rm non_newAbinsGI_*.txt 2> smallerrors
rm non_newBbinsGI_*.txt 2> smallerrors
rm combined_newAbinsGI_*.txt 2> smallerrors
rm combined_newBbinsGI_*.txt 2> smallerrors
rm smallerrors
exit 0
fi

rm GIrestmpfile
finalout=`echo "$outpre""mergedCrush_""$minres"".bedgraph"`
finalpout=`echo "$outpre""mergedqvalue_""$minres"".bedgraph"`
Afinalout=`echo "mergedCrush_A_""$minres"".bedgraph"`
Bfinalout=`echo "mergedCrush_B_""$minres"".bedgraph"`
Crush_todelete=`echo "Crush_todelete"`
pval_todelete=`echo "pval_todelete"`
cat Crush_*.bedgraph | mawk -v minr=$minres '{print $1"\t"$2/minr"\t"$3/minr"\t"$4/int($3-$2)}' | mawk -v mr=$minres '{for (i=$2;i<$3;i++) print $1":"int(i)*mr":"(int(i)+1)*mr"\t"$4}' | mawk '{c1[$1] += $2; c2[$1]++} END {for (i in c1) print i"\t"c1[i]/c2[i]}' | sed 's/:/\t/g' > $finalout 2> smallerrors
#cat pvalues_*.bedgraph | mawk -v minr=$minres '{print $1"\t"$2/minr"\t"$3/minr"\t"$4}' | mawk -v mr=$minres '{for (i=$2;i<$3;i++) print $1":"int(i)*mr":"(int(i)+1)*mr"\t"$4}' | mawk '{c1[$1] += $2; c2[$1]++} END {for (i in c1) print i"\t"c1[i]/c2[i]}' | sed 's/:/\t/g' > $finalpout 2> smallerrors
cat pvalues_*.bedgraph | mawk -v minr=$minres '{print $1"\t"$2/minr"\t"$3/minr"\t"$4}' | mawk -v mr=$minres '{for (i=$2;i<$3;i++) print $1":"int(i)*mr":"(int(i)+1)*mr"\t"$4}' | awk '{c1[$1] += log($2)/log(10); c2[$1]++} END {for (i in c1) print i"\t"10**(c1[i]/c2[i])}' | sed 's/:/\t/g' | sort -k 1,1 -V -k 2bn,2b --stable > $finalpout 2> smallerrors
wait

cat << EOF > BHcorrection.py
from statsmodels.stats.multitest import multipletests
inputfile="$finalpout"
outfile="bhcorrected"
mystarts=[]
mychr=[]
myends=[]
mypvals=[]
with open(inputfile, 'r') as innie:
        for line in innie:
                sline = line.strip()
                lines = sline.split("\t")
                mychr.append(str(lines[0]))
                mystarts.append(str(lines[1]))
                myends.append(str(lines[2]))
                mypvals.append(float(lines[3]))
hyptest, FDRlist, _, alpha_corrected =multipletests(mypvals, alpha=0.5, method='fdr_bh', is_sorted=False, returnsorted=False)
with open(outfile, 'w') as outie:
        for w in range(0,len(FDRlist)):
                outie.write(str(mychr[w]) + "\t" + str(mystarts[w]) + "\t" + str(myends[w]) + "\t" + str(FDRlist[w]) + "\n")

EOF

python BHcorrection.py

wait
mv bhcorrected $finalpout
wait
GIave=`cat $finalout | mawk '{if ($4 < 0) sum+=($4*-1); else sum+=($4)} END {print sum/NR}' `

if [ $(bc <<< "$qthresh > 0") -eq 1 ]
then
finaloutfilt=`echo "$outpre""mergedCrush_""$minres""_qfiltered.bedgraph"`
filt_todelete=`echo "tmpcrushfiltered"`
mawk -v fdr=$qthresh -v var=$GIave 'NR==FNR {a[$1":"$2":"$3] = $4; next} {if (a[$1":"$2":"$3] <= fdr) print $1"\t"$2"\t"$3"\t"$4/(var/100)}'  $finalpout $finalout > $finaloutfilt
wait

fi


if [ $trackline -eq 0 ]
then
cat $finalout | mawk -v var=$GIave '{print $1"\t"$2"\t"$3"\t"$4/(var/100)}' > $Crush_todelete
cat $finalpout | mawk '{print $1"\t"$2"\t"$3"\t"$4}' > $pval_todelete
wait
else
cat $finalout | mawk -v var=$GIave '{print $1"\t"$2"\t"$3"\t"$4/(var/100)}' | mawk '{if (NR == 1) print "track type=bedgraph visibility=full color=0,120,0 altColor=127,0,127 viewLimits=-20,20 autoScale off\n"$0; else print $0}' > $Crush_todelete
cat $finalpout | mawk '{if (NR == 1) print "track type=bedgraph visibility=full color=0,120,0 altColor=127,0,127 viewLimits=-20,20 autoScale off\n"$1"\t"$2"\t"$3"\t"$4; else print $1"\t"$2"\t"$3"\t"$4}' > $pval_todelete
wait
fi
wait

if [ $trackline -gt 0 ] && [ $(bc <<< "$qthresh > 0") -eq 1 ]
then
cat $finaloutfilt | mawk '{if (NR == 1) print "track type=bedgraph visibility=full color=0,120,0 altColor=127,0,127 viewLimits=-20,20 autoScale off\n"$0; else print $0}' > $filt_todelete
wait
mv $filt_todelete $finaloutfilt
mv $Crush_todelete $finalout
mv $pval_todelete $finalpout
wait
fi

if [ $keeptracks -eq 1 ]
then
cat ACrush_*.bedgraph | mawk -v minr=$minres '{print $1"\t"$2/minr"\t"$3/minr"\t"$4}' | mawk -v mr=$minres '{for (i=$2;i<$3;i++) print $1"\t"int(i)*mr"\t"(int(i)+1)*mr"\t"$4}' | sort -k 1,1 -V -k 2bn,2b -k 3bn,3b --stable | groupBy -i stdin -g 1,2,3 -c 4 -o sum > $Afinalout 2> smallerrors&
cat BCrush_*.bedgraph | mawk -v minr=$minres '{print $1"\t"$2/minr"\t"$3/minr"\t"$4}' | mawk -v mr=$minres '{for (i=$2;i<$3;i++) print $1"\t"int(i)*mr"\t"(int(i)+1)*mr"\t"$4}' | sort -k 1,1 -V -k 2bn,2b -k 3bn,3b --stable | groupBy -i stdin -g 1,2,3 -c 4 -o sum > $Bfinalout 2> smallerrors &
fi
wait

#rm Crush_*.bedgraph 2> smallerrors
#rm ACrush_*.bedgraph 2> smallerrors
#rm BCrush_*.bedgraph 2> smallerrors
#rm AbinsfromGI_*.txt 2> smallerrors
#rm BbinsfromGI_*.txt 2> smallerrors
#rm newAbinsGI_*.txt 2> smallerrors
#rm newBbinsGI_*.txt 2> smallerrors
#rm non_newAbinsGI_*.txt 2> smallerrors
#rm non_newBbinsGI_*.txt 2> smallerrors
#rm combined_newAbinsGI_*.txt 2> smallerrors
#rm combined_newBbinsGI_*.txt 2> smallerrors
#rm smallerrors

#############################################################################
##Refixing the extra bins
#Creating a size bed file
sizeBed=`echo "Chrsizes.bed"`
finalout2=`echo "mergedCrush2_""$minres"".bedgraph"`

cat $sizefile | awk '{print $1"\t""1""\t"$2}' > $sizeBed

#Intersecting with the sizes bed file to remove any extra bins and adding colors Red and Black to the compartments.
cat $finalout | grep -v track | intersectBed -wa -a stdin -wb -b $sizeBed | awk '{if ($3 <= $7) print $0}' | cut -f 1-4 | mawk '{if (NR == 1) print "track type=bedgraph visibility=full color=204,0,0 altColor=0,0,0 viewLimits=-100,100 autoScale off\n"$0; else print $0}'> $finalout2
mv $finalout2 $finalout
if [ $(bc <<< "$qthresh > 0") -eq 1 ]
then
cat $finaloutfilt | grep -v track | intersectBed -wa -a stdin -wb -b $sizeBed | awk '{if ($3 <= $7) print $0}' | cut -f 1-4 | mawk '{if (NR == 1) print "track type=bedgraph visibility=full color=204,0,0 altColor=0,0,0 viewLimits=-100,100 autoScale off\n"$0; else print $0}'> $filt_todelete
wait
mv $filt_todelete $finaloutfilt
fi


#rm $sizeBed
#rm Crush_*.bedgraph 2> smallerrors
#rm ACrush_*.bedgraph 2> smallerrors
#rm BCrush_*.bedgraph 2> smallerrors
#rm AbinsfromGI_*.txt 2> smallerrors
#rm BbinsfromGI_*.txt 2> smallerrors
#rm newAbinsGI_*.txt 2> smallerrors
#rm newBbinsGI_*.txt 2> smallerrors
#rm non_newAbinsGI_*.txt 2> smallerrors
#rm non_newBbinsGI_*.txt 2> smallerrors
#rm combined_newAbinsGI_*.txt 2> smallerrors
#rm combined_newBbinsGI_*.txt 2> smallerrors
#rm smallerrors

#copy files and move back out of crushdir
mv $finalout ../
mv $finalpout ../
if [ $(bc <<< "$qthresh > 0") -eq 1 ]
then
mv $finaloutfilt ../
fi

cd ../
if [ "$cleanup" -gt 0 ]
then
echo "cleaning up"
rm -r $crushdir
fi

echo "Finished! Check ""$finalout"


##############################################################################

